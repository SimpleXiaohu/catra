package uuverifiers.parikh_theory
import ap.terfor.{TermOrder, Formula, Term, OneTerm, VariableTerm}
import ap.terfor.TerForConvenience._
import scala.collection.mutable.{ArrayBuffer, BitSet => MBitSet}
import ap.terfor.linearcombination.LinearCombination
import ap.basetypes.IdealInt
import ap.terfor.conjunctions.Conjunction

class PresburgerParikhImage[A <: Automaton](private val aut: A)
    extends Tracing {
  private lazy val stateSeq = aut.states.toIndexedSeq
  private lazy val state2Index = stateSeq.iterator.zipWithIndex.toMap

  def parikhImage(
      charCounts: Seq[Term],
      toCharIncrement: aut.Transition => Seq[IdealInt]
  )(implicit order: TermOrder): Formula = trace("PresburgerParikhImage") {
    lazy val preStates = {
      val preStates =
        Array.fill(stateSeq.size)(
          new ArrayBuffer[(Int, List[IdealInt])]
        )

      for (transition @ (from, label, to) <- aut.transitions) {
        val vector = toCharIncrement(transition).toList
        preStates(state2Index(to)) += ((state2Index(from), vector))
      }

      preStates
    }

    lazy val transPreStates = {
      val transPreStates = Array.fill(stateSeq.size)(new MBitSet)

      // transPreStates clone from preStates
      for ((array, s2) <- preStates.iterator zip transPreStates.iterator)
        for ((s1, _) <- array)
          s2 += s1

      for ((s, n) <- transPreStates.iterator.zipWithIndex)
        s += n

      var changed = false
      do {
        for (outgoing <- transPreStates) {
          val oldSize = outgoing.size

          for (target <- outgoing)
            // FIXME: only look at the new targets in next iteration!
            outgoing |= transPreStates(target)

          changed = outgoing.size > oldSize
        }
      } while (changed)

      transPreStates
    }
    val initialStateInd = state2Index(aut.initialState)

    ////////////////////////////////////////////////////////////////////////////

    // disjunction of formulas
    val rawDisjunction = disjFor(
      for (finalState <- aut.states.filter(aut.isAccept(_)))
        yield {
          val finalStateInd = state2Index(finalState)
          val refStates = transPreStates(finalStateInd)

          // FIXME: remove self-loops maybe?
          // [to, Option[from] [labels]]
          val productions: List[(Int, Option[Int], List[IdealInt])] =
            (if (refStates contains initialStateInd)
               List((initialStateInd, None, List()))
             else List()) ::: // FIXME: why concat?
              (for (state <- refStates.iterator;
                    preState <- preStates(state))
                yield (state, Some(preState._1), preState._2)).toList

          val prodVars = productions.view.zipWithIndex.map {
            case (_, i) => v(i)
          }
          val zVars = refStates
            .zip(Stream from prodVars.size)
            .map {
              case (state, index) =>
                state -> v(index)
            }
            .toMap

          // Generate 0 - 2 variable -> coefficient * term mappings from a
          // transition , eg.
          // A TRANS TO would give
          //   [A -> 1 * Y_A->B,
          //    B -> -1 * Y_A->B]
          def stateTermsFromTransition(
              t: ((Int, Option[Int], Any), Term)
          ): List[(Int, (IdealInt, Term))] =
            t match {
              // Ignore self-loops:
              case ((to, Some(from), _), _) if from == to => List()
              case ((to, None, _), v)                     => List((to, (IdealInt.MINUS_ONE, v)))
              case ((to, Some(from), _), v) =>
                List((to, (IdealInt.MINUS_ONE, v)), (from, (IdealInt.ONE, v)))
            }

          // Translate the weird output of groupBy to actual linear
          // combinations using the coefficients generated by
          // stateTermsFromTransition. For the final state, add +1 to the
          // terms as per the algorithm.
          def termsToLinearEq(
              st: ((Int, List[(Int, (IdealInt, Term))]))
          ): LinearCombination = {
            val (state, state_terms) = st
            val terms = state_terms.map(_._2)

            if (state == finalStateInd)
              LinearCombination((IdealInt.ONE, OneTerm) :: terms, order)
            else LinearCombination(terms, order)
          }

          // [((to, from, registers), Z_prod)]
          val prodsWithVars = productions.zip(prodVars).toList

          // equations relating the production counters
          // consistent
          // Transition equations (for non-terminals)
          // [Eq(0/1  +/- Y_transition_1, ..., +/- Y_transition_n),
          // ... ] (+ for from, - for to), one per terminal involved
          // NOTE: This is backwards compared to the paper: 1 on final, reversed sign on from/to
          val prodEqs = prodsWithVars
            .map(stateTermsFromTransition)
            .flatten
            .groupBy(_._1) // group by state
            .map(termsToLinearEq) // translate to each state's equation

          // Take a character variable c and its offset iand produce a linear
          // combination like c = SUM of t: y_t * toCharIncrement(t)(i)
          def makeCharCountTerms(ci: (Term, Int)): LinearCombination = {
            val (c, i) = ci
            val prodTerms: Seq[(IdealInt, Term)] =
              aut.transitions.zip(prodVars.iterator).toSeq.map {
                case (t, prodVar) => (toCharIncrement(t)(i), prodVar)
              }

            LinearCombination(prodTerms :+ (IdealInt.MINUS_ONE, c), order)
          }

          // for each register, generate a linear combination of -1 * r +
          // [y_A->B * s(r)], where s(r) for each register r, where s(r) is
          // the...state of register r at state s.
          // val rEqs = registers.zipWithIndex
          //   .map(makeRegisterTerms)
          // val rEqs = List()

          // A list of equations on the format
          // - char(c) + SUM of t: y_t * toCharIncrement(t)(c)
          val charCountEqs = charCounts.zipWithIndex.map(makeCharCountTerms)

          val entryZEq = zVars(finalStateInd) - 1

          val allEqs = eqZ(Iterator(entryZEq) ++ prodEqs ++ charCountEqs)

          val prodNonNeg = prodVars >= 0

          // Production implications: either we didn't use a production, or
          // its corresponding target is greater than zero.
          val prodImps = prodsWithVars
            .filter { case ((to, _, _), _) => to != finalStateInd }
            .map {
              case ((to, _, _), prodVar) => (prodVar === 0) | zVars(to) > 0
            }

          val connective = refStates
            .filter(finalStateInd.!=)
            .map(
              state =>
                disjFor(
                  (zVars(state) === 0) ::
                    prodsWithVars
                      .filter {
                        case ((_, from, _), _) => from contains state
                      }
                      .map {
                        case ((to, _, _), prodVar) =>
                          conj(
                            zVars(state) === zVars(to) + 1,
                            geqZ(List(prodVar - 1, zVars(to) - 1))
                          )
                      }
                )
            )

          val matrix =
            conj(Iterator(allEqs, prodNonNeg) ++ prodImps ++ connective)
          val rawConstraint =
            exists(prodVars.size + zVars.size, matrix)

          rawConstraint
        }
    )

    if (rawDisjunction.variables.isEmpty) {
      rawDisjunction
    } else {
      val maxVar =
        (for (VariableTerm(n) <- rawDisjunction.variables) yield n).max
      exists(maxVar + 1, rawDisjunction)
    }
  }
}
